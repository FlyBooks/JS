<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>释放内存</title>
<script>
	/*
	
	 * 作用域： 全局跟局部
	 局部作用域： 函数定义的时候产生，作用域函数定义好就一直存在，且不会反复定义
	
	 垃圾回收机制（garbage collection）：是一个循环机制
	 1. 计数清除
	 看内存的地址身上有几个指针指向，当一块内存地址身上指针个数为0,说明这块内存马上要被回收了
	 2. 标记清除
	 进入代码执行的时候，检测到需要使用的变量就在其身上加一个标记；在代码执行完的时候（函数），就会在之前加了标记的变量再添加一个出场标签。
	 */

	/*
	对象的创建方式：
	1. Object构造函数方式，缺点： 语句太多，流程太啰嗦
	2. 对象的 字面量创建， 优点：书写简单，方便，直观    缺点：有太多的重复代码
	3. 工厂模式: 优点：避免重复的代码,可以批量生产对象    缺点:不能明确缺乏属于哪一类
	4. 自定义构造函数： 优点：可以生成多个实例对象。 缺点：方法如果直接定义给实例本身，则太占内存了
	
	 */

	/*
	继承：
	1.原型继承：
		子类的原型对象 === 父类的实例， 例如： Child.prototype = new Parent();
	注意点： 以上的步骤会导致子类原型的构造器属性丢失，所以需要手动添加构造器属性
	-Child.prototype.constructor = Child;
	
	2.借用构造函数继承（不是真正意义上的继承）：在子类的构造函数中调用父类的构造函数
	注意点： 父类构造函数的this指向问题
	解决方案： apply/this强制改变this的指向 --》当前子类的实例对象
	
	 */
</script>
</head>
<body>

</body>
</html>